# AZ_SE_HW2
### Yasin Moosavi 98110351
### Matin Moradi 98104488
میخواهیم  TDD پیش برویم پس اول  یک تست میسازیم که فیل میشود زیرا کلاس  reactangle را نداریم:

![image](https://github.com/yasin459/AZ_SE_HW2/assets/60640286/aee11d82-2b04-4887-b3ad-2ae00a68ce23)

کلاس rectangle را میسازیم و اینبار به درستی ران میشود:

![image](https://github.com/yasin459/AZ_SE_HW2/assets/60640286/a2153986-894c-4665-b48e-4782ea76afb8)

حال باید مساحت را حساب کنیم و تست آن میشود:

![image](https://github.com/yasin459/AZ_SE_HW2/assets/60640286/b664b158-fa40-4421-b392-eca97efd66ca)

اما تایع تعریف نشده پس آن را تعریف میکنیم:

![image](https://github.com/yasin459/AZ_SE_HW2/assets/60640286/55959874-2e42-4d22-94d6-c115e619ad5f)

اما همچنان فیل میشود پس متغیر های دیگری را هم اضافه میکنیم:

![image](https://github.com/yasin459/AZ_SE_HW2/assets/60640286/36706ba5-e37b-4fe7-8b4b-1d1f7ac9ff28)

و تست ما هم میشود: که باز هم فیل میشود چراکه  constructor نداریم:

![image](https://github.com/yasin459/AZ_SE_HW2/assets/60640286/e63d6f44-a75d-4c88-9664-348b50b3cbcb)

برای درست کردن آن کد میشود:

![image](https://github.com/yasin459/AZ_SE_HW2/assets/60640286/3b238d89-967b-42b5-aba0-e70e2cf0fcfc)

و تست پاس میشود پس تست جدید میسازیم: این دو تست برای بررسی setter  و  getter  هستند، به طور مشابه اینها هم مشکل نبود  getter setter میخورند که با اضافه کردن کد به فایل rectangle درست میشود:

![image](https://github.com/yasin459/AZ_SE_HW2/assets/60640286/4145fa20-fd62-46ad-a844-9e95bd6b3abd)


کد getter , setter:

![image](https://github.com/yasin459/AZ_SE_HW2/assets/60640286/a7e563ad-7b65-41e0-a92c-1a947e0aab42)

و تست ها پاس میشوند:

![image](https://github.com/yasin459/AZ_SE_HW2/assets/60640286/bad1b5c4-494e-4cc2-9ec2-a0adca49fcdd)

حال باید مربع را اضافه کنیم، اول تست آن:

![image](https://github.com/yasin459/AZ_SE_HW2/assets/60640286/2e0cfbdc-5a16-4cce-8d08-41c9e70d1fab)

که فیل میشود پس یک کلاس مربع میسازیم:

![image](https://github.com/yasin459/AZ_SE_HW2/assets/60640286/f31c659f-b9a9-449d-b192-dd0c00dc590e)

و تست پاس میشود:

![image](https://github.com/yasin459/AZ_SE_HW2/assets/60640286/46842f05-3d9b-4e46-9f2e-e30b4e7b2abb)

حال باید تستی جدید بنویسیم که توابع بالا را بتوان روی مربع هم ست کرد برای اینکار دو راه حل داریم، یکی اینکه مربع از مستطیل ارث بری کند که این غلط است و دیگری این است که هردو از یک کلاس  shape  ارث بری کنند. حال دقت کنید که تمام توابعی که برای  rect زدیم باید برای shape و square هم کار کنند پس در گام اول تست های نوشته شده را برای  shape باز نویسی میکنیم: البته ست های قبلی را هم نگه میداریم.

![image](https://github.com/yasin459/AZ_SE_HW2/assets/60640286/7c105e0e-45df-4c36-9861-187ce6a28f23)


بنابراین تمام این توابع را باید بریا  shape  بنویسیم:

![image](https://github.com/yasin459/AZ_SE_HW2/assets/60640286/d67eaf5d-1554-4b71-b61f-77a7ea45c947)

و توابع کلاس های Square , Rectangle  را حذف میکنیم:

![image](https://github.com/yasin459/AZ_SE_HW2/assets/60640286/8bfefbe6-a093-45ed-b8f7-0efa91cb702b)

 حال تست ها را ران میکنیم و میبینیم که تست های  Shape ران میشود و تست های  rectangle ران نمیشود:

 ![image](https://github.com/yasin459/AZ_SE_HW2/assets/60640286/8a86bdbc-883a-46f7-abd8-ab298073f24b)

 برای تایید شدن این توابع باقی مانده باید rectangle از  shape ارث ببرد:

 ![image](https://github.com/yasin459/AZ_SE_HW2/assets/60640286/bad1bece-0f93-4962-aa3b-27334dc283a0)

 دوباره ران میکنیم:

 ![image](https://github.com/yasin459/AZ_SE_HW2/assets/60640286/dd9dbed9-bc47-4a81-971c-7024717772dc)

 حال که همگی  accept شدند، سراغ  square میرویم و برای آن هم ارث بری  را اجرا میکنیم:

 ![image](https://github.com/yasin459/AZ_SE_HW2/assets/60640286/994ca74e-c86c-41bc-a81c-c4c3d597a3bc)

 و تست ها را دوباره ران میگیریم:

 ![image](https://github.com/yasin459/AZ_SE_HW2/assets/60640286/5e8663a8-94b8-4c1d-a3e6-4f3d5881d7b9)

 با اینکار همه ی تست ها اکسپت میشود و صرفا تست اخر اکسپت نمیشود که دلیل آن هم این است که به آن ورودی نداده ایم.

 ![image](https://github.com/yasin459/AZ_SE_HW2/assets/60640286/7bf13dc9-3948-4a40-a4f0-7530c6654a95)

 






### پرسش ها

1. هر یک از پنج اصل SOLID را در دو الی سه خط توضیح دهید.
   1. اصل SRP (Single Responsibility Principle):
هر ماژول یا کلاس باید مسئولیت یک وظیفه یا عملکرد خاص را داشته باشد و باید تنها به یک دلیل برای تغییر تحت فشار قرار گیرد.

   2. اصل OCP (Open-Closed Principle):
   کلاس‌ها باید برای توسعه باز باشند، یعنی باید قابلیت افزودن عملکردهای جدید را داشته ولی باید برای تغییر بسته باشند، یعنی تغییر در عملکردهای قبلی کلاس باید از طریق گسترش و تغییراتی در کلاس‌های مشتق شده انجام شود.
   
   3. اصل LSP (Liskov Substitution Principle):
   هر کلاس مشتق شده باید قابل جایگزینی با کلاس پایه باشد، به این معنی که باید همهٔ عملکردهای کلاس پایه را پشتیبانی کند و از نظر رفتاری با کلاس پایه سازگار باشد.
   
   4. اصل ISP (Interface Segregation Principle):
   برای جلوگیری از وابستگی نامناسب، باید به جای وابستگی به کلاس‌ها، به وابستگی به رابط‌ها توجه کنیم و در طراحی سیستم، باید رابط‌ها را به گونه‌ای طراحی کنیم که کلاس‌هایی که از آن استفاده می‌کنند، فقط به عملکردهای مورد نیاز خود دسترسی داشته باشند.
   
   5. اصل DIP (Dependency Inversion Principle):
   باید برای کاهش وابستگی، وابستگی به اشیاء بالاتر در سلسله مراتب را کاهش داده و به جای آن، باید به وابستگی به ابسترکشن‌ها و رابط‌هایی که به اشیاء پایین‌تر در سلسله مراتب وابسته‌اند، توجه کنیم. به این ترتیب، اشیاء پایین‌تر می‌توانند به سادگی با اشیاء جایگزین شوند و بهبود پذیری سیستم افزایش یابد.


2. اصول SOLID در کدام یک از گام‌های اصلی ایجاد نرم‌افزار (تحلیل نیازمندی‌ها، طراحی، پیاده‌سازی، تست و استقرار) استفاده می‌شوند؟ توضیح دهید.


   اصول SOLID در تمامی مراحل ایجاد نرم‌افزار، از تحلیل نیازمندی‌ها تا استقرار، بکار می‌روند. در زیر به توضیح نحوه استفاده از اصول SOLID در هر گام اصلی ایجاد نرم‌افزار می‌پردازم:

   1. تحلیل نیازمندی‌ها:
   در این مرحله، اصول SOLID می‌توانند به عنوان راهنمایی برای تعیین مسئولیت‌ها و وظایف هر کلاس در سیستم مورد نیاز باشند. به عنوان مثال، با استفاده از اصل SRP، می‌توان به طور دقیق تر تعیین کرد که هر کلاس باید چه عملکردهایی را انجام دهد و همچنین با استفاده از اصل ISP، می‌توان رابط‌هایی را برای کلاس‌ها طراحی کرد تا به مرور زمان و با توسعه سیستم، وابستگی‌های نامناسبی به وجود نیاید.
   
   2. طراحی:
   در این مرحله، اصول SOLID به عنوان راهنمایی برای طراحی کلاس‌ها و رابط‌ها مورد استفاده قرار می‌گیرند. مثلاً با استفاده از اصل OCP، می‌توان در طراحی کلاس‌ها به گسترش پذیری سیستم با توجه به تغییرات در آینده توجه کرد و با استفاده از اصل LSP، می‌توان کلاس‌ها را به گونه‌ای طراحی کرد که به راحتی قابل جایگزینی با کلاس‌های دیگر باشند.
   
   3. پیاده‌سازی:
   در این مرحله، اصول SOLID به عنوان راهنمایی برای پیاده‌سازی کلاس‌ها و رابط‌ها مورد استفاده قرار می‌گیرند. برای مثال، با استفاده از اصل DIP، می‌توان وابستگی‌های نامناسب را به کلاس‌های پایین‌تر در سلسله مراتب کاهش داد و از وابستگی به اشیاء بالاتر در سلسله مراتب جلوگیری کرد.
   
   4. تست:
   در این مرحله، اصول SOLID به عنوان راهنمایی برای طراحی تست‌ها و ارزیابی کد مورد استفاده قرار می‌گیرند. با استفاده از اصل SRP، می‌توان کدها را به بخش‌های کوچک تر تقسیم کرد تا به راحتی قابل تست باشند.
   
   5. استقرار:
   در این مرحله، اصول SOLID به عنوان راهنمایی برای ایجاد سیستمی با امنیت و پایداری بالا مورد استفاده قرار می‌گیرند. به عنوع، با استفاده از اصل OCP و LSP، می‌توان سیستم را به گونه‌ای طراحی کرد که به سادگی قابل توسعه و قابلیت جایگزینی با سیستم‌های دیگر داشته باشد. همچنین، با استفاده از اصل ISP، می‌توان رابط‌هایی را برای سیستم طراحی کرد که فقط به عملکردهای مورد نیاز سیستم دسترسی داشته باشند و از احتمال وقوع خطاهای امنیتی جلوگیری کنند. در کل، اصول SOLID در تمامی مراحل ایجاد نرم‌افزار به عنوان راهنمایی و اصولی که برای طراحی سیستم بهینه و قابل توسعه باید رعایت شوند، مورد استفاده قرار می‌گیرند.


3. در چرخه‌ی عمومی ایجاد نرم‌افزار، آزمون نرم‌افزار دیرتر از پیاده‌سازی نرم‌افزار انجام می‌شود، اما در روش TDD تست‌نویسی پیش از پیاده‌سازی شروع می‌شود. آیا این دو مورد با هم تناقضی دارند؟ توضیح دهید.
   بله، به نظر می‌رسد که این دو مورد در تناقض با یکدیگر هستند، اما در واقع این دو رویکرد متفاوت برای آزمون نرم‌افزار هستند که هر کدام مزایا و معایب خود را دارند.

   در روش توسعه مبتنی بر تست (TDD)، ابتدا تست‌ها نوشته شده و به عنوان معیار برای پیاده‌سازی نرم‌افزار استفاده می‌شوند. این روش از مزایای بالایی برای توسعه نرم‌افزار برخوردار است، مانند کاهش هزینه تست، کاهش خطاها، افزایش سرعت توسعه و ایجاد کد قابل مدیریت‌تر و قابل توسعه‌تر. اما این روش ممکن است باعث ایجاد تست‌های زیادی شود که زمان بیشتری برای نوشتن و اجرا آنها نیاز است.
   
   در چرخه‌ی عمومی ایجاد نرم‌افزار، پیاده‌سازی نرم‌افزار انجام شده و سپس تست‌هایی که برای بررسی کارکرد نرم‌افزار نوشته شده‌اند، اجرا می‌شوند. این روش در مواردی مفید است که نرم‌افزار به صورت سریع باید تحویل داده شود و زمان کافی برای نوشتن تست‌های کامل و کارآمد وجود ندارد. اما این روش ممکن است باعث ایجاد خطاهای بیشتری شود و نیاز به زمان بیشتری برای پیدا کردن و رفع خطاها داشته باشد.
   
   بنابراین، هر دو رویکرد مورد استفاده قرار می‌گیرند و هر کدام برای موارد خاصی مناسب هستند. اما در کل، استفاده از روش TDD به عنوان یک رویکرد پایه برای توسعه نرم‌افزار و کاهش هزینه‌های تست و رفع خطاها می‌تواند مفید باشد.


4. فرض کنید در آزمایش بالا نیازی به تغییر ابعاد مستطیل نداشتیم. آیا در این حالت می‌توانستیم مربع را از مستطیل به ارث ببریم؟ توضیح دهید.
5. 
   باز هم نمیشد چون بایستی اصل liskov substitution principle را رعایت کنیم و در این اصل باید پیش زمینه های فرزند نباید پدر را محدود کند، برای مثال در حال حاضر مستطیل میتواند تمام ورودی های عددی را به عنوان طول بگیرد و به ازای آنها یک مساحت خروجی دهد اما مربع باید طول هر 4 ضلعش با هم برابر باشند که در اینصورت برخی از ورودی های کلاس پدر را نمیتواند بپذیرد. بنابراین نمیتوان آن را به عنوان فرزند کلاس مستطیل در نظر گرفت.









 



